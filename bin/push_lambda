#!/usr/bin/env node

require('dotenv').config()
const ChildProcess = require('child_process')
const Crypto = require('crypto')
const JSZip = require('jszip')
const Lambda = require('aws-sdk/clients/lambda')
const MemoryFS = require('memory-fs')
const Path = require('path')
const Webpack = require('webpack')

const LAMBDA_FUNCTION_NAME = 'purvisresearch-middleware'

const config = {
  entry: Path.resolve('lambda/middleware/index.js'),
  mode: process.env.NODE_ENV,
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: 'babel-loader',
        options: {
          presets: [
            [
              '@babel/preset-env',
              {
                corejs: 3,
                targets: {
                  node: '10.15',
                },
                useBuiltIns: 'usage'
              },
            ],
          ],
        },
        exclude: /(node_modules)/
      }
    ]
  },
  output: {
    filename: 'index.js',
    libraryTarget: 'commonjs2',
    path: '/'
  },
  resolve: {
    alias: {
      '~': Path.resolve(__dirname)
    }
  },
  target: 'node',
}

function createCodeSha256(buffer) {
  let hash = Crypto.createHash('sha256')
  hash.update(buffer)
  return hash.digest('base64')
}

async function compileToBuffer(config) {
  const outputPath = Path.join(config.output.path, config.output.filename)
  const { memoryfs } = await compileToMemoryFS(config)
  const buffer = memoryfs.readFileSync(outputPath)
  return buffer
}

async function compileToMemoryFS(config, memoryfs = new MemoryFS()) {
  const compiler = Webpack(config)
  compiler.outputFileSystem = memoryfs
  return new Promise((resolve, reject) => {
    compiler.run((error, stats) => {
      if (error) {
        reject(error)
      } else if (stats.hasErrors()) {
        reject(new Error(stats.toJson().errors))
      } else {
        resolve({ memoryfs, stats })
      }
    })
  })
}

async function exec(command, options) {
  return new Promise((resolve, reject) => {
    ChildProcess.exec(command, options, (error, stdout, stderr) => {
      error ? reject(error) : resolve({ stdout, stderr })
    })
  })
}

async function getMostRecentCommitDate(path) {
  return exec(`git log -1 --format=%cd ${path}`)
    .then(({ stdout }) => {
      const date = new Date(stdout)
      if (date instanceof Date && !isNaN(date))
        return date
      else
        throw new Error('Could not parse date!')
    })
}

async function getRemoteCodeSha256(functionName) {
  return new Lambda()
    .getFunctionConfiguration({
      FunctionName: functionName,
    })
    .promise()
    .then(result => result.CodeSha256)
}

async function updateFunctionCode(functionName, buffer) {
  return new Lambda()
    .updateFunctionCode({
      FunctionName: functionName,
      ZipFile: buffer,
    })
    .promise()
}

async function zipToBuffer(data, options) {
  return new JSZip()
    .file("index.js", data, options)
    .generateAsync({
      compression: "DEFLATE",
      compressionOptions: {
        level: 9,
      },
      platform: "UNIX",
      type: "nodebuffer",
    })
}

Promise
  .all([
    compileToBuffer(config),
    getMostRecentCommitDate(Path.dirname(config.entry)),
  ])
  .then(([buffer, date]) =>
    zipToBuffer(buffer, { date })
  )
  .then(buffer => Promise.all([
    buffer,
    createCodeSha256(buffer),
    getRemoteCodeSha256(LAMBDA_FUNCTION_NAME),
  ]))
  .then(([buffer, localCodeSha, remoteCodeSha]) => {
    console.log(`Comparing code sha values...`)
    console.log(`local:   ${localCodeSha}`)
    console.log(`remote:  ${remoteCodeSha}`)
    if (localCodeSha == remoteCodeSha) {
      console.log('Everything up-to-date')
      process.exit()
    }
    console.log('Updating function code...')
    return updateFunctionCode(LAMBDA_FUNCTION_NAME, buffer)
  })
  .then(result =>
    console.log(`Code updated successfully (Revision ID ${result.RevisionId})`)
  )
  .catch(console.error)
